Назначение


Паттерн Abstract Factory - предоставляет клиенту интерфейс (набор методов) для создания семейств взаимосвязанных или взаимозависимых 
объектов-продуктов, при этом скрывает от клиента информацию о конкретных классах создаваемых объектов-продуктов.



Применимость паттерна


Паттерн Abstract Factory рекомендуется использовать, когда:

- Требуется создавать объекты-продукты разных типов и налаживать между ними взаимодействие, 
при этом образуя семейства из этих объектов-продуктов. Входящие в семейство объекты-продукты обязательно должны использоваться вместе.

- Требуется построить подсистему (модуль или компонент) таким образом, чтобы ее внутреннее устройство 
(состояние и/или поведение) настраивалось при ее создании. При этом чтобы ни процесс, ни результат построения подсистемы не был зависим 
от способа создания в ней объектов, их композиции (составления и соединения объектов) и представления (настройки внутреннего состояния объектов).

- Подсистема или система должна настраиваться (конфигурироваться) через использование одного из семейств объектов-продуктов, 
порождаемых одним объектом-фабрикой;



Результаты


Паттерн Abstract Factory обладает следующими преимуществами:

- Сокрытие работы с конкретными классами продуктов.
Фабрика скрывает от клиента детали реализации конкретных классов и процесс создания экземпляров этих классов. 
Конкретные классы-продуктов известны только конкретным фабрикам и в коде клиента они не используются. 
Клиент управляет экземплярами конкретных классов только через их абстрактные интерфейсы.

- Позволяет легко заменять семейства используемых продуктов.
Экземпляр класса конкретной фабрики создается в приложении в одном месте и только один раз, 
что позволяет в дальнейшем проще подменять фабрики. Для того чтобы изменить семейство 
используемых продуктов, нужно просто создать новый экземпляр класса-фабрики, 
тогда заменится сразу все семейство.

- Обеспечение совместного использования продуктов.
Позволяет легко контролировать взаимодействие между объектами-продуктами, 
которые спроектированы для совместного использования и входят в одно семейство.


Паттерн Abstract Factory обладает следующим недостатком:

- Имеется небольшое неудобство добавления нового вида продуктов.
Для создания нового вида продуктов потребуется создать новые классы продуктов (абстрактные и конкретные), 
добавить новый абстрактный фабричный метод в абстрактный класс фабрики и реализовать этот абстрактный метод 
в производных конкретных классах фабриках, а также изменить код класса Client.



Реализация


Полезные приемы реализации паттерна Abstract Factory:

- Объекты-фабрики существуют в единственном экземпляре. 
В подсистеме, создается только один экземпляр класса ConcreteFactory для порождения, соответствующего семейства продуктов.

- Создание объектов-продуктов. 
Класс AbstractFactory предоставляет только интерфейс (набор абстрактных методов) для создания продуктов. Фактически 
продукты создаются в фабричных методах производных конкретных классов-фабрик. Конкретная фабрика реализует фабричные методы, 
которые возвращают ссылки на создаваемые ими экземпляры продуктов.

- Определение расширяемых фабрик. 
Класс AbstractFactory содержит абстрактные операции для создания продуктов. Имена фабричных методов включают 
в себя название типа порождаемого продукта. Для добавления нового вида продуктов нужно добавить новый абстрактный фабричный 
метод в абстрактный класс AbstractFactory и реализовать этот метод в производных классах-фабриках.

Более гибкий способ – использовать фабричные методы с аргументами, описывающими виды создаваемых продуктов. 
Тип аргумента может быть числовой, строковой или типом перечисления (enum), однозначно описывающий тип порождаемого продукта. 
При таком подходе абстрактному классу AbstractFactory нужна только одна операция Make с аргументом, указывающим тип создаваемого продукта.
Интересные и гибкие варианты порождения можно организовать в динамически типизированных языках, каким и является C#. 
Языки с поддержкой динамической типизации позволяют создавать семейства продуктов без наличия общего абстрактного базового класса, 
а фабричные методы могут иметь возвращаемые значения динамического типа (dynamic). Также в языке C# абстрактный класс можно заменить 
конструкцией языка выражающей такой стереотип как «интерфейс» (interface IAbstractFactory).

Если в клиенте отказаться от приведения продуктов к базовому абстрактному типу то, можно было бы выполнить динамическое приведение 
типа (например, с помощью оператора dynamic в C#), но это не всегда безопасно и не всегда заканчивается успешно. 
Может возникнуть проблемная ситуация: все продукты будут возвращаться клиенту с интерфейсом, который не отображается в intellisense 
(intellisense – механизм автодополнения), клиенту будет сложно различать динамические типы продуктов, и могут возникать сложности 
с их использованием. Такие варианты представляют собой пример компромисса между гибкостью, расширяемостью интерфейса и производительностью.