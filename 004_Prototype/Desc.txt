Назначение


Паттерн Prototype – предоставляет возможность создания новых объектов-продуктов (клонов), используя технику клонирования (копирования) 
созданного ранее объекта-оригинала-продукта (прототипа). Паттерн Prototype – позволяет задать различные виды (классы-виды) объектов-продуктов 
(клонов), через настройку состояния каждого нового созданного клона. Классификация клонов-продуктов производится на основании различия их 
состояний.
См. пример: \CBS_implementations\001_MusicalEditor\



Применимость паттерна


Паттерн Prototype рекомендуется использовать, когда:

 Программист не должен знать, как в системе создаются, компонуются и представляются объекты-продукты.

 Классы, экземпляры которых требуется создать, определяются во время выполнения программы, например, с использованием техники позднего 
связывания (динамическая загрузка DLL).

 Требуется избежать построения параллельных иерархий классов (фабрик или продуктов).

 Экземпляры определенного класса могут иметь небольшое количество состояний. Тогда может оказаться удобнее установить прототип 
в соответствие каждому уникальному состоянию и в дальнейшем клонировать прототипы, а не создавать экземпляры вручную и не настраивать 
состояние этих экземпляров каждый раз заново.

 Требуется создать некоторое количество экземпляров с одинаковым долго-вычисляемым состоянием. В этом случае для повышения производительности 
удобнее создать прототип и его клонировать, причем с использованием метода MemberwiseClone класса System.Object входящего в поставку 
Microsoft .NET Framework. Клонирование с использованием конструктора повышения производительности не даст.
См. пример: См. пример: \CBS_implementations\002_Performance



Результаты


Многие особенности применения паттерна Prototype совпадают с особенностями применения паттернов Abstract Factory и Builder:

 Сокрытие работы с конкретными классами продуктов.

 Возможность легкой замены семейств используемых продуктов.

 Обеспечение совместного использования продуктов.

 Имеется небольшое неудобство добавления нового вида продуктов.

 Возможность изменения состава продукта.

 Сокрытие кода, реализующего конструирование и представление.

 Контроль над процессом построения продукта.


Дополнительные особенности результатов применения паттерна Prototype:

 Возможность добавления и удаления продуктов во время выполнения.
Паттерн Prototype позволяет добавлять новую разновидность «классов-продуктов» во время выполнения программы за счет 
конфигурирования состояния объекта-клона полученного в результате клонирования объекта-прототипа. «Класс-продукт» следует понимать 
не как конструкцию языка C# (class), а как «вид-продукт» получившийся за счет конфигурации состояния объекта-клона.
(см. пример: \CBS_implementations\003_ObjectClass)

 Описание новых типов объектов (объектов-классов) путем изменения состояния клонов.
Программные системы позволяют формировать состояние и поведение сложных объектов-клонов за счет композиции состояний и поведений 
более простых объектов. При этом для представления сложного состояния объекта, не требуется создавать новых классов (class).

 Уменьшение числа производных классов.
Большинство порождающих паттернов используют иерархии классов продуктов параллельные иерархиям классов фабрик. 
Паттерн Prototype через клонирование и настройку объектов-продуктов позволяет избавиться от наличия иерархии фабрик, порождающих продукты.

 Динамическое добавление классов во время выполнения программы.
Платформа .Net позволяет динамически подключать новые классы к исполняющемуся приложению и создавать экземпляры этих 
классов (late binding - позднее связывание). Приложение, создающее экземпляры динамически загружаемого класса, не имеет возможности 
вызывать конструктор напрямую. Вместо этого на классе-объекте Activator вызывается метод CreateInstance, которому в качестве аргумента 
передается строковое представление полного квалифицированного имени класса, экземпляр которого требуется создать, например, 
Activator.CreateInstance("MyNamespace.MyClass"). Паттерн Prototype в определенных случаях может стать гибкой альтернативой позднему связыванию 
избавляя от многократного инстанцирования классов, подключаемых динамически. Достаточно создать один экземпляр-прототип и в дальнейшем его клонировать. 
Такой подход может дать выигрыш в производительности при необходимости создания большого количества однотипных экземпляров классов.


При клонировании могут возникнуть проблемы корректного клонирования ассоциаций. Особое внимание требуется обращать на клонирование двухсторонних ассоциаций.