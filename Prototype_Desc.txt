Назначение


Паттерн Prototype – предоставляет возможность создания новых объектов-продуктов (клонов), используя технику клонирования (копирования) 
созданного ранее объекта-оригинала-продукта (прототипа). Паттерн Prototype – позволяет задать различные виды (классы-виды) объектов-продуктов 
(клонов), через настройку состояния каждого нового созданного клона. Классификация клонов-продуктов производится на основании различия их 
состояний.
См. пример: \CBS_implementations\001_MusicalEditor



Применимость паттерна


Паттерн Prototype рекомендуется использовать, когда:

 Программист не должен знать, как в системе создаются, компонуются и представляются объекты-продукты.

 Классы, экземпляры которых требуется создать, определяются во время выполнения программы, например, с использованием техники позднего 
связывания (динамическая загрузка DLL).

 Требуется избежать построения параллельных иерархий классов (фабрик или продуктов).

 Экземпляры определенного класса могут иметь небольшое количество состояний. Тогда может оказаться удобнее установить прототип 
в соответствие каждому уникальному состоянию и в дальнейшем клонировать прототипы, а не создавать экземпляры вручную и не настраивать 
состояние этих экземпляров каждый раз заново.

 Требуется создать некоторое количество экземпляров с одинаковым долго-вычисляемым состоянием. В этом случае для повышения производительности 
удобнее создать прототип и его клонировать, причем с использованием метода MemberwiseClone класса System.Object входящего в поставку 
Microsoft .NET Framework. Клонирование с использованием конструктора повышения производительности не даст.
См. пример: См. пример: \CBS_implementations\002_Performance



Результаты


Многие особенности применения паттерна Prototype совпадают с особенностями применения паттернов Abstract Factory и Builder:

 Сокрытие работы с конкретными классами продуктов.

 Возможность легкой замены семейств используемых продуктов.

 Обеспечение совместного использования продуктов.

 Имеется небольшое неудобство добавления нового вида продуктов.

 Возможность изменения состава продукта.

 Сокрытие кода, реализующего конструирование и представление.

 Контроль над процессом построения продукта.


Дополнительные особенности результатов применения паттерна Prototype:

 Возможность добавления и удаления продуктов во время выполнения.
Паттерн Prototype позволяет добавлять новую разновидность «классов-продуктов» во время выполнения программы за счет 
конфигурирования состояния объекта-клона полученного в результате клонирования объекта-прототипа. «Класс-продукт» следует понимать 
не как конструкцию языка C# (class), а как «вид-продукт» получившийся за счет конфигурации состояния объекта-клона.
(см. пример: \CBS_implementations\003_ObjectClass)

 Описание новых типов объектов (объектов-классов) путем изменения состояния клонов.
Программные системы позволяют формировать состояние и поведение сложных объектов-клонов за счет композиции состояний и поведений 
более простых объектов. При этом для представления сложного состояния объекта, не требуется создавать новых классов (class).

 Уменьшение числа производных классов.
Большинство порождающих паттернов используют иерархии классов продуктов параллельные иерархиям классов фабрик. 
Паттерн Prototype через клонирование и настройку объектов-продуктов позволяет избавиться от наличия иерархии фабрик, порождающих продукты.

 Динамическое добавление классов во время выполнения программы.
Платформа .Net позволяет динамически подключать новые классы к исполняющемуся приложению и создавать экземпляры этих 
классов (late binding - позднее связывание). Приложение, создающее экземпляры динамически загружаемого класса, не имеет возможности 
вызывать конструктор напрямую. Вместо этого на классе-объекте Activator вызывается метод CreateInstance, которому в качестве аргумента 
передается строковое представление полного квалифицированного имени класса, экземпляр которого требуется создать, например, 
Activator.CreateInstance("MyNamespace.MyClass"). Паттерн Prototype в определенных случаях может стать гибкой альтернативой позднему связыванию 
избавляя от многократного инстанцирования классов, подключаемых динамически. Достаточно создать один экземпляр-прототип и в дальнейшем его клонировать. 
Такой подход может дать выигрыш в производительности при необходимости создания большого количества однотипных экземпляров классов.


При клонировании могут возникнуть проблемы корректного клонирования ассоциаций. Особое внимание требуется обращать на клонирование двухсторонних ассоциаций.



Реализация


Использование паттерна Prototype может оказаться полезным в статически типизированных языках вроде C#, где классы не являются объектами. 
Меньше всего паттерн Prototype может оказаться полезным в прототипно-ориентированных языках вроде JavaScript, так как в основе таких языков 
уже заложена конструкция эквивалентная прототипу, это – «объект-класс». В прототипно-ориентированных языках создание любого объекта производится 
путем клонирования прототипа и такие языки базируются именно на идеях использования паттерна Prototype.

Вопросы, которые могут возникнуть при реализации прототипов:

 Использование диспетчера прототипов.
Если в программе требуется создавать большое число прототипов и при этом заранее не известно сколько прототипов может понадобиться, 
то есть смысл использовать вспомогательный объект для создания прототипов и контроля над ними. Такой объект будет представлять собой 
реестр прототипов или его можно назвать - «диспетчер прототипов». Реестр прототипов – представляет собой ассоциативную коллекцию типа 
хеш-таблицы или словаря, в которой в соответствие ключам поставлены объекты-прототипы. Реестр может возвращать ссылку на прототип или 
непосредственно на построенный клон прототипа, это зависит от желаемой логики.

 Реализация метода Clone.
Самый ответственный момент при использовании паттерна Prototype – реализация метода Clone. Особое внимание потребуется при наличии ассоциаций 
в клонируемом прототипе.
Паттерн Prototype, выражен в платформе .Net в виде техники клонирования, через использование реализации интерфейса ICloneable или метода 
MemberwiseClone класса System.Object. Но метод MemberwiseClone не решает проблему «глубокого и поверхностного клонирования». При клонировании 
с использованием метода MemberwiseClone следует учитывать следующие особенности:

	- Граф наследования всегда клонируется глубоко.

	- Могут возникнуть проблемы корректного клонирования ассоциаций. Так как ассоциации клонируются поверхностно. Перед клонированием следует 
	  ответить на вопрос: должны ли при клонировании объекта клонироваться также и другие объекты на которые ссылаются переменные клонируемого 
	  объекта, или клон будет использовать эти объекты совместно с оригиналом?

	- Особо внимание требуется обратить на клонирование двухсторонних ассоциаций.
См. Пример к главе: \CBS_implementations\004_Features

 Инициализация клонов.
Часто, сразу после клонирования, требуется производить настройку (изменение) состояния объекта-клона (полностью или частично). Можно задуматься над тем, 
чтобы передавать параметры в метод Clone перед началом клонирования, но такой подход считается неудачным, так как мешает построению единообразного 
интерфейса клонирования. Для таких случаев, будет целесообразно ввести набор методов для установки или очистки важных элементов состояния, или ввести 
один метод Initialize который будет принимать параметры для установки состояния клона.